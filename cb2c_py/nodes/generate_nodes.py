import os
import json
import re
from typing import Dict, List, Any
from .node_discovery import fetch_node_definitions

# Directory to save the generated node files
OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "generated")

# Python class template
CLASS_TEMPLATE = '''
# This file is auto-generated by generate_nodes.py
# Do not edit this file directly.

from ..base_node import Node, InputSlots, OutputSlots, Slot, Model, Conditioning, Latent, Image, Vae, Clip
from typing import Dict, Any, List

# Define input and output slot classes for {class_name}
class {class_name}Inputs(InputSlots):
{input_slots_annotations}
    def __init__(self, node: "Node"):
{input_slots_assignments}

class {class_name}Outputs(OutputSlots):
{output_slots_annotations}
    def __init__(self, node: "Node"):
{output_slots_assignments}

class {class_name}(Node[{class_name}Inputs, {class_name}Outputs]):
    """
    Original name: {original_name}
    {docstring}
    """
    _original_name: str = {original_name_repr}

    def __init__(self, {init_params}):
        super().__init__(**{super_init_params})
        self.inputs = {class_name}Inputs(self)
        self.outputs = {class_name}Outputs(self)
'''


def sanitize_name(name: str) -> str:
    """
    Converts a name into a valid Python identifier.
    """
    # Replace any non-alphanumeric characters with an underscore
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    # If the name starts with a digit, prepend an underscore
    if sanitized and sanitized[0].isdigit():
        sanitized = "_" + sanitized
    return sanitized


def get_python_type(slot_type: Any) -> str:
    """
    Maps a ComfyUI slot type to a Python type hint.
    """
    if isinstance(slot_type, list):
        return "str"  # This is an enum of strings

    # Mapping for simple types
    type_map = {
        "INT": "int",
        "FLOAT": "float",
        "STRING": "str",
        "BOOLEAN": "bool",
    }
    if str(slot_type) in type_map:
        return type_map[str(slot_type)]

    # Mapping for complex, Slot-based types
    slot_type_map = {
        "MODEL": "Slot[Model]",
        "CONDITIONING": "Slot[Conditioning]",
        "LATENT": "Slot[Latent]",
        "IMAGE": "Slot[Image]",
        "VAE": "Slot[Vae]",
        "CLIP": "Slot[Clip]",
    }
    # Fallback for any other types
    return slot_type_map.get(str(slot_type), "Slot[Any]")


def generate_node_files() -> None:
    """
    Fetches node definitions, generates a Python file for each node,
    and creates an __init__.py to make them importable as a package.
    """
    print("Starting node generation process...")
    node_definitions = fetch_node_definitions()

    if not node_definitions:
        print("Could not fetch node definitions. Aborting.")
        return

    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    generated_classes: Dict[str, str] = {}
    node_manifest: Dict[str, Dict[str, Any]] = {}

    for original_name, details in node_definitions.items():
        class_name = sanitize_name(original_name)

        if class_name in generated_classes:
            print(f"Warning: Sanitized name collision for '{original_name}'. Skipping.")
            continue

        docstring = details.get("_meta", {}).get("description", "No description available.")
        inputs_data = details.get("input", {}).get("required", {})
        
        # Prepare input slot definitions
        input_slots_annotations = []
        input_slots_assignments = []
        for name, config in inputs_data.items():
            s_name = sanitize_name(name)
            slot_type = config[0]
            py_type = get_python_type(slot_type)
            # For inputs, the annotation is always a Slot type
            slot_py_type = py_type if "Slot" in py_type else f"Slot[{py_type}]"
            input_slots_annotations.append(f"    {s_name}: {slot_py_type}")
            input_slots_assignments.append(f'        self.{s_name} = {slot_py_type}(node, "{s_name}", {repr(slot_type)})')
        if not input_slots_assignments:
            input_slots_assignments.append("        pass")

        output_slots_annotations = []
        output_slots_assignments = []
        output_names = []
        for i, (name, slot_type) in enumerate(zip(details.get("output_name", []), details.get("output", []))):
            prop_name = sanitize_name(name.lower())
            py_type = get_python_type(slot_type)
            slot_py_type = py_type if "Slot" in py_type else f"Slot[{py_type}]"
            output_slots_annotations.append(f"    {prop_name}: {slot_py_type}")
            output_slots_assignments.append(f'        self.{prop_name} = {slot_py_type}(node, "{name}", {repr(slot_type)})')
            output_names.append(prop_name)
        if not output_slots_assignments:
            output_slots_assignments.append("        pass")

        # Generate the __init__ method signature
        init_params_list: List[str] = []
        super_init_params_list: List[str] = []
        
        params_with_defaults: List[str] = []
        params_without_defaults: List[str] = []

        for name, config in inputs_data.items():
            s_name = sanitize_name(name)
            slot_type = config[0]
            py_type = get_python_type(slot_type)
            param_opts = config[1] if len(config) > 1 else {}

            if "default" in param_opts:
                default_value = repr(param_opts["default"])
                params_with_defaults.append(f"{s_name}: {py_type} = {default_value}")
            else:
                params_without_defaults.append(f"{s_name}: {py_type}")
            
            super_init_params_list.append(f'"{name}": {s_name}')

        init_params_list = params_without_defaults + params_with_defaults
        
        file_content = CLASS_TEMPLATE.format(
            class_name=class_name,
            original_name=original_name.replace('"', "'"),
            original_name_repr=repr(original_name),
            docstring=docstring,
            input_slots_annotations="\n".join(input_slots_annotations),
            input_slots_assignments="\n".join(input_slots_assignments),
            output_slots_annotations="\n".join(output_slots_annotations),
            output_slots_assignments="\n".join(output_slots_assignments),
            init_params=", ".join(init_params_list),
            super_init_params=f"{{{', '.join(super_init_params_list)}}}",
        )

        module_name = class_name.lower()
        file_path = os.path.join(OUTPUT_DIR, f"{module_name}.py")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(file_content)
            generated_classes[class_name] = module_name
            node_manifest[original_name] = {
                "class_name": class_name,
                "module_name": module_name,
                "output_names": output_names,
            }
        except IOError as e:
            print(f"Error writing file {file_path}: {e}")

    print(f"\nSuccessfully generated {len(generated_classes)} node files.")

    # Generate __init__.py
    init_path = os.path.join(OUTPUT_DIR, "__init__.py")
    sorted_class_names = sorted(generated_classes.keys())
    import_lines = [f"from .{generated_classes[name]} import {name}" for name in sorted_class_names]
    all_list = json.dumps(sorted_class_names, indent=4)
    init_content = (
        "# This file is auto-generated by generate_nodes.py. Do not edit.\n"
        + "\n".join(import_lines)
        + f"\n\n__all__ = {all_list}\n"
    )
    try:
        with open(init_path, "w", encoding="utf-8") as f:
            f.write(init_content)
        print("Successfully created __init__.py.")
    except IOError as e:
        print(f"Error writing __init__.py: {e}")

    # Generate node_manifest.json
    manifest_path = os.path.join(OUTPUT_DIR, "node_manifest.json")
    try:
        with open(manifest_path, "w", encoding="utf-8") as f:
            json.dump(node_manifest, f, indent=4)
        print("Successfully created node_manifest.json.")
    except IOError as e:
        print(f"Error writing node_manifest.json: {e}")

    print("\nNode generation complete.")


if __name__ == "__main__":
    generate_node_files()
