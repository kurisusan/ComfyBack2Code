import os
import json
import re
from typing import Dict, List, Any, Optional
from .node_discovery import fetch_node_definitions

# Directory to save the generated node files
OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "generated")

# Python class template
CLASS_TEMPLATE = '''
# This file is auto-generated by generate_nodes.py
# Do not edit this file directly.

from ..base_node import Node, InputSlots, OutputSlots, Slot, Model, Conditioning, Latent, Image, Vae, Clip
from typing import Dict, Any, List, Union

# Define input and output slot classes for {class_name}
class {class_name}Inputs(InputSlots):
{input_slots_annotations}
    def __init__(self, node: "Node"):
{input_slots_assignments}

class {class_name}Outputs(OutputSlots):
{output_slots_annotations}
    def __init__(self, node: "Node"):
{output_slots_assignments}

class {class_name}(Node[{class_name}Inputs, {class_name}Outputs]):
    """
    Original name: {original_name}
    Category: {category}
    {description}

    Inputs:
{inputs_doc}

    Outputs:
{outputs_doc}
    """
    _original_name: str = {original_name_repr}

    def __init__(self, {init_params}):
        super().__init__(**{super_init_params})
        self.inputs = {class_name}Inputs(self)
        self.outputs = {class_name}Outputs(self)
'''


def sanitize_name(name: str) -> str:
    """
    Converts a name into a valid Python identifier.
    """
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    if sanitized and sanitized[0].isdigit():
        sanitized = "_" + sanitized
    return sanitized


def get_python_type(slot_type: Any) -> str:
    """
    Maps a ComfyUI slot type to a Python type hint.
    """
    if isinstance(slot_type, list):
        return "str"  # This is an enum of strings

    type_map = {
        "INT": "int", "FLOAT": "float", "STRING": "str", "BOOLEAN": "bool",
    }
    if str(slot_type) in type_map:
        return type_map[str(slot_type)]

    slot_type_map = {
        "MODEL": "Slot[Model]", "CONDITIONING": "Slot[Conditioning]",
        "LATENT": "Slot[Latent]", "IMAGE": "Slot[Image]", "VAE": "Slot[Vae]",
        "CLIP": "Slot[Clip]", "MASK": "Slot[Image]",
    }
    return slot_type_map.get(str(slot_type), "Slot[Any]")


def get_python_type_for_input(slot_type: Any, default_value: Optional[Any]) -> str:
    """
    Determines the Python type for an input, creating a Union if the default
    value's type conflicts with the primary slot type.
    """
    primary_py_type = get_python_type(slot_type)

    if isinstance(slot_type, list) or str(slot_type) == "COMBO":
        return "str"

    if default_value is None:
        return primary_py_type

    default_py_type = ""
    if isinstance(default_value, str): default_py_type = "str"
    elif isinstance(default_value, bool): default_py_type = "bool"
    elif isinstance(default_value, float): default_py_type = "float"
    elif isinstance(default_value, int): default_py_type = "int"

    if default_py_type and primary_py_type != default_py_type and "Slot" not in primary_py_type:
        return f"Union[{primary_py_type}, {default_py_type}]"

    return primary_py_type


def get_valid_default_value(default_value: Any, slot_type: Any) -> str:
    """
    Returns the repr of the default value, ensuring it's a string for COMBOs.
    """
    if isinstance(slot_type, list) or str(slot_type) == "COMBO":
        return repr(str(default_value))
    return repr(default_value)


def generate_node_files() -> None:
    """
    Fetches node definitions and generates a Python file for each node.
    """
    print("Starting node generation process...")
    node_definitions = fetch_node_definitions()
    if not node_definitions:
        print("Could not fetch node definitions. Aborting.")
        return

    os.makedirs(OUTPUT_DIR, exist_ok=True)
    generated_classes: Dict[str, str] = {}

    for original_name, details in node_definitions.items():
        class_name = sanitize_name(original_name)
        if class_name in generated_classes:
            print(f"Warning: Sanitized name collision for '{original_name}'. Skipping.")
            continue

        inputs_data = details.get("input", {}).get("required", {})
        
        input_slots_annotations, input_slots_assignments = [], []
        inputs_doc_list = []
        for name, config in inputs_data.items():
            s_name = sanitize_name(name)
            slot_type, param_opts = config[0], config[1] if len(config) > 1 else {}
            default_val = param_opts.get("default")
            tooltip = param_opts.get("tooltip")
            
            py_type = get_python_type_for_input(slot_type, default_val)
            slot_py_type = py_type if "Slot" in py_type else f"Slot[{py_type}]"
            
            input_slots_annotations.append(f"    {s_name}: {slot_py_type}")
            input_slots_assignments.append(f'        self.{s_name} = {slot_py_type}(node, "{s_name}", {repr(slot_type)})')
            
            doc_type = get_python_type(slot_type).replace('Slot[', '').replace(']', '')
            doc_line = f"        - {s_name} ({doc_type})"
            if "default" in param_opts:
                doc_line += f" (default: {get_valid_default_value(default_val, slot_type)})"
            if tooltip:
                doc_line += f"\n          {tooltip}"
            inputs_doc_list.append(doc_line)

        if not input_slots_assignments: input_slots_assignments.append("        pass")
        if not inputs_doc_list: inputs_doc_list.append("        No inputs.")

        output_slots_annotations, output_slots_assignments = [], []
        outputs_doc_list = []
        output_tooltips = details.get("output_tooltips", [])
        for i, (name, slot_type) in enumerate(zip(details.get("output_name", []), details.get("output", []))):
            prop_name = sanitize_name(name.lower())
            py_type = get_python_type(slot_type)
            slot_py_type = py_type if "Slot" in py_type else f"Slot[{py_type}]"
            output_slots_annotations.append(f"    {prop_name}: {slot_py_type}")
            output_slots_assignments.append(f'        self.{prop_name} = {slot_py_type}(node, "{name}", {repr(slot_type)})')
            
            doc_type = py_type.replace('Slot[', '').replace(']', '')
            doc_line = f"        - {prop_name} ({doc_type})"
            if i < len(output_tooltips) and output_tooltips[i]:
                doc_line += f"\n          {output_tooltips[i]}"
            outputs_doc_list.append(doc_line)

        if not output_slots_assignments: output_slots_assignments.append("        pass")
        if not outputs_doc_list: outputs_doc_list.append("        No outputs.")

        params_with_defaults, params_without_defaults = [], []
        for name, config in inputs_data.items():
            s_name = sanitize_name(name)
            slot_type, param_opts = config[0], config[1] if len(config) > 1 else {}
            default_val = param_opts.get("default")
            py_type = get_python_type_for_input(slot_type, default_val)

            if "default" in param_opts:
                default_value_str = get_valid_default_value(default_val, slot_type)
                params_with_defaults.append(f"{s_name}: {py_type} = {default_value_str}")
            else:
                params_without_defaults.append(f"{s_name}: {py_type}")
        
        init_params_list = params_without_defaults + params_with_defaults
        super_init_params_list = [f'"{name}": {sanitize_name(name)}' for name in inputs_data]
        
        file_content = CLASS_TEMPLATE.format(
            class_name=class_name,
            original_name=original_name.replace('"', "'"),
            original_name_repr=repr(original_name),
            category=details.get("category", "Unknown"),
            description=details.get("description", "No description available."),
            inputs_doc="\n".join(inputs_doc_list),
            outputs_doc="\n".join(outputs_doc_list),
            input_slots_annotations="\n".join(input_slots_annotations),
            input_slots_assignments="\n".join(input_slots_assignments),
            output_slots_annotations="\n".join(output_slots_annotations),
            output_slots_assignments="\n".join(output_slots_assignments),
            init_params=", ".join(init_params_list),
            super_init_params=f"{{{', '.join(super_init_params_list)}}}",
        )

        module_name = class_name.lower()
        file_path = os.path.join(OUTPUT_DIR, f"{module_name}.py")
        with open(file_path, "w", encoding="utf-8") as f: f.write(file_content)
        generated_classes[class_name] = module_name

    print(f"\nSuccessfully generated {len(generated_classes)} node files.")

    init_path = os.path.join(OUTPUT_DIR, "__init__.py")
    sorted_class_names = sorted(generated_classes.keys())
    import_lines = [f"from .{generated_classes[name]} import {name}" for name in sorted_class_names]
    with open(init_path, "w", encoding="utf-8") as f:
        f.write("# This file is auto-generated by generate_nodes.py. Do not edit.\n")
        f.write("\n".join(import_lines))
        f.write(f"\n\n__all__ = {json.dumps(sorted_class_names, indent=4)}\n")
    print("Successfully created __init__.py.")
    print("\nNode generation complete.")

if __name__ == "__main__":
    generate_node_files()
