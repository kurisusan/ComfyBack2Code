import os
import json
import re
from .node_discovery import fetch_node_definitions
from .base_node import Node

# Directory to save the generated node files
OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "generated")

# Python class template
CLASS_TEMPLATE = '''
# This file is auto-generated by generate_nodes.py
# Do not edit this file directly.

from ..base_node import Node

class {class_name}(Node):
    """
    Original name: {original_name}
    {docstring}
    """
    _inputs = {inputs}
    _outputs = {outputs}
    _original_name = "{original_name}"

    def __init__(self, {init_params}):
        super().__init__({super_init_params})

    @classmethod
    def get_inputs(cls):
        return cls._inputs

    @classmethod
    def get_outputs(cls):
        return cls._outputs
'''

def sanitize_name(name):
    """
    Converts a node name into a valid Python identifier.
    It replaces invalid characters and ensures the name doesn't start with a digit.
    """
    # Replace characters that are invalid in Python identifiers
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    
    # Ensure it doesn't start with a number
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
        
    return sanitized

def generate_node_files():
    """
    Fetches node definitions, generates a Python file for each node,
    and creates an __init__.py to make them importable as a package.
    """
    print("Starting node generation process...")
    node_definitions = fetch_node_definitions()

    if not node_definitions:
        print("Could not fetch node definitions. Aborting.")
        return

    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    generated_classes = {}

    for original_name, details in node_definitions.items():
        class_name = sanitize_name(original_name)
        
        # Handle potential name collisions after sanitization
        if class_name in generated_classes:
            print(f"Warning: Sanitized name collision for '{original_name}'. Skipping.")
            continue

        # Prepare documentation and input/output data for the template
        docstring = details.get('_meta', {}).get('description', 'No description available.')
        inputs_data = details.get('input', {}).get('required', {})
        inputs = json.dumps(inputs_data, indent=4).replace('true', 'True').replace('false', 'False').replace('null', 'None')
        outputs = json.dumps(details.get('output', []), indent=4)

        # Generate the __init__ method signature
        init_params = []
        super_init_params = []
        
        # Separate params with and without default values
        params_with_defaults = []
        params_without_defaults = []

        for name, config in inputs_data.items():
            # config is a list, e.g., ["STRING", {"default": "Hello"}]
            param_type = config[0]
            param_opts = config[1] if len(config) > 1 else {}
            
            sanitized_name = sanitize_name(name)

            if 'default' in param_opts:
                default_value = param_opts['default']
                if isinstance(default_value, str):
                    # Escape backslashes and then wrap in quotes
                    default_value = f'"{default_value.encode("unicode_escape").decode()}"'
                params_with_defaults.append(f"{sanitized_name}={default_value}")
            else:
                params_without_defaults.append(sanitized_name)
            super_init_params.append(f"{sanitized_name}={sanitized_name}")
        
        init_params = params_without_defaults + params_with_defaults

        # Generate the class file content
        file_content = CLASS_TEMPLATE.format(
            class_name=class_name,
            original_name=original_name.replace("\"", "'"), # Escape quotes for the string
            docstring=docstring,
            inputs=inputs,
            outputs=outputs,
            init_params=", ".join(init_params),
            super_init_params=", ".join(super_init_params)
        )

        # Write the content to a file (e.g., ksampler.py)
        module_name = class_name.lower()
        file_path = os.path.join(OUTPUT_DIR, f"{module_name}.py")
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(file_content)
            generated_classes[class_name] = module_name
        except IOError as e:
            print(f"Error writing file {file_path}: {e}")

    print(f"\nSuccessfully generated {len(generated_classes)} node files.")
    
    # Now, generate the __init__.py file
    print("Generating __init__.py to create a package...")
    init_path = os.path.join(OUTPUT_DIR, "__init__.py")
    
    sorted_class_names = sorted(generated_classes.keys())
    
    import_lines = [
        f"from .{generated_classes[name]} import {name}" for name in sorted_class_names
    ]
    
    all_list = json.dumps(sorted_class_names, indent=4)

    init_content = (
        "# This file is auto-generated by generate_nodes.py. Do not edit.\n"
        + "\n".join(import_lines)
        + f"\n\n__all__ = {all_list}\n"
    )

    try:
        with open(init_path, 'w', encoding='utf-8') as f:
            f.write(init_content)
        print("Successfully created __init__.py.")
    except IOError as e:
        print(f"Error writing __init__.py: {e}")

    print(f"\nNode generation complete. You can now import nodes from 'cb2c_py.nodes.generated'")


if __name__ == "__main__":
    generate_node_files()
